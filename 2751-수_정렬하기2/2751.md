# 2751:수 정렬하기

## 푼 날짜(4/22)

## 문제

수 N개를 주어진 순서대로 정렬하는 프로그램을 작성하시오.

## 입력

첫째 줄에 수의 개수 N(1 ≤ N ≤ 1,000,000)이 주어진다.
둘째 줄에는 수가 주어진다. 수는 절댓값이 1,000,000보다 작거나 같은 정수이다. 수는 중복되지 않는다.

## 출력

첫째 줄부터 N개의 줄에 오름차순으로 정렬한 결과를 한 줄에 하나씩 출력한다.

## 풀이

아마 실버5 정도부터는 받는 파일이 매우 커지고, 입출력에 병목이 오는 경우가 있습니다. 이런 경우에는 parsing을 하거나, log를 하는 방법을 다르게 고안 해야 겠지요.

```
for (const num of arr) {
  console.log(num);
}
```

이런경우에는 출력에 병목이 오기 때문에

```
console.log(arr.join("\n"));
```

이렇게 수정은 해야 합니다.

## 매우 중요한 겯들임

알고리즘이 만약 다음과 같은 시간 복잡도가 되면, 어느 경우가 더 빠를 것이라 생각하나요?

O(1000000n) vs O(n^2)

생각을 해보면 상수부는 빅O 표기법에서, 날려야 하니까, O(n) vs O(n^2)가 되고, 자연스럽게, O(n)이 더 빠를 것이라 예상 할수 있겠지요.

근데 이번 코드 예제를 보면, 가장 높은 시간 복잡도를 띄는 코드가 sort인데, 이것은 O(NlogN) 복잡도를 띄죠.
그래서 위에서 log를 loop를 돌려서 준 부분은 시간 복잡도가 O(n)이기 때문에 저 전체 프로그램의 복잡도는 O(NlogN)가 되어요. 저 루프는 비교대상에서 빠지죠.

그런데 시간복잡도 개념으로 생각해보면, join으로 준 코드가 O(1)이고, 최종적인 시간 복잡도는 O(NlogN)이 되어도, 시간에 차이가 많이 나요!

어? 그러면 어떻게 생각해야 하나요? 빅 오를 사용하는것을 하지 않아야 하나요? 부정확 하니까요?

그것 보다는, 그냥 빅오로 시간 복잡도를 계산하는것은 편의상, 직관상 계산을 편하게 한다고만 생각하시고,**무조건 이것이 실제 속도로 귀결된다는 생각은 버려야 합니다.**

에이, O(1000000n) 정도면, O(n^2) 보다 한두개는 더 느릴수도 있지요. 아닐수도 있지만...

편의상은 일단 빅 오로 접근을 해보고, 만약 시간초과가 뜬다면 상수부도 날리지 말고 세세하게 계산을 할 필요가 생길수도 있습니다.

이렇게 접어두지요.

=> 과제 : **빅세타(Θ)나 빅오메가(Ω)를 사용하지 않는 이유는 무엇일까요?** 직접 알아보고 함께 논의해 봅시다. GPT를 활용해도 좋습니다.
